import {
  MAGIC_COMMENT_STATIC
} from "./chunk-CDKBJE3E.mjs";

// src/ast.ts
import { babelParse as _babelParse, walkIdentifiers } from "@vue/compiler-sfc";
function babelParse(code, lang) {
  const plugins = [];
  if (lang) {
    if (/^[cm]?tsx?$/.test(lang))
      plugins.push("typescript");
    if (/^[cm]?[jt]sx$/.test(lang))
      plugins.push("jsx");
  }
  const { program } = _babelParse(code, {
    sourceType: "module",
    plugins
  });
  return program;
}
function isCallOf(node, test) {
  return !!(node && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
}
function checkInvalidScopeReference(node, method, setupBindings) {
  if (!node)
    return;
  walkIdentifiers(node, (id) => {
    if (setupBindings.includes(id.name))
      throw new SyntaxError(
        `\`${method}()\` in <script setup> cannot reference locally declared variables (${id.name}) because it will be hoisted outside of the setup() function.`
      );
  });
}
function isStaticExpression(node) {
  var _a;
  if ((_a = node.leadingComments) == null ? void 0 : _a.some(
    (comment) => comment.value.trim() === MAGIC_COMMENT_STATIC
  ))
    return true;
  switch (node.type) {
    case "UnaryExpression":
      return isStaticExpression(node.argument);
    case "LogicalExpression":
    case "BinaryExpression":
      return isStaticExpression(node.left) && isStaticExpression(node.right);
    case "ConditionalExpression":
      return isStaticExpression(node.test) ? isStaticExpression(node.consequent) : isStaticExpression(node.alternate);
    case "SequenceExpression":
    case "TemplateLiteral":
      return node.expressions.every((expr) => isStaticExpression(expr));
    case "ArrayExpression":
      return node.elements.every(
        (element) => element && isStaticExpression(element)
      );
    case "ObjectExpression":
      return node.properties.every(
        (prop) => prop.type === "ObjectProperty" && (isStaticExpression(prop.key) || !prop.computed) && isStaticExpression(prop.value)
      );
    case "ParenthesizedExpression":
    case "TSNonNullExpression":
    case "TSAsExpression":
    case "TSTypeAssertion":
      return isStaticExpression(node.expression);
  }
  if (isLiteralType(node))
    return true;
  return false;
}
function isLiteralType(node) {
  return node.type.endsWith("Literal");
}

export {
  babelParse,
  isCallOf,
  checkInvalidScopeReference,
  isStaticExpression,
  isLiteralType
};
