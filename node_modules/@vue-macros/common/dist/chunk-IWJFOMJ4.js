"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunkARAOJUFSjs = require('./chunk-ARAOJUFS.js');

// src/ast.ts
var _compilersfc = require('@vue/compiler-sfc');
function babelParse(code, lang) {
  const plugins = [];
  if (lang) {
    if (/^[cm]?tsx?$/.test(lang))
      plugins.push("typescript");
    if (/^[cm]?[jt]sx$/.test(lang))
      plugins.push("jsx");
  }
  const { program } = _compilersfc.babelParse.call(void 0, code, {
    sourceType: "module",
    plugins
  });
  return program;
}
function isCallOf(node, test) {
  return !!(node && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
}
function checkInvalidScopeReference(node, method, setupBindings) {
  if (!node)
    return;
  _compilersfc.walkIdentifiers.call(void 0, node, (id) => {
    if (setupBindings.includes(id.name))
      throw new SyntaxError(
        `\`${method}()\` in <script setup> cannot reference locally declared variables (${id.name}) because it will be hoisted outside of the setup() function.`
      );
  });
}
function isStaticExpression(node) {
  var _a;
  if ((_a = node.leadingComments) == null ? void 0 : _a.some(
    (comment) => comment.value.trim() === _chunkARAOJUFSjs.MAGIC_COMMENT_STATIC
  ))
    return true;
  switch (node.type) {
    case "UnaryExpression":
      return isStaticExpression(node.argument);
    case "LogicalExpression":
    case "BinaryExpression":
      return isStaticExpression(node.left) && isStaticExpression(node.right);
    case "ConditionalExpression":
      return isStaticExpression(node.test) ? isStaticExpression(node.consequent) : isStaticExpression(node.alternate);
    case "SequenceExpression":
    case "TemplateLiteral":
      return node.expressions.every((expr) => isStaticExpression(expr));
    case "ArrayExpression":
      return node.elements.every(
        (element) => element && isStaticExpression(element)
      );
    case "ObjectExpression":
      return node.properties.every(
        (prop) => prop.type === "ObjectProperty" && (isStaticExpression(prop.key) || !prop.computed) && isStaticExpression(prop.value)
      );
    case "ParenthesizedExpression":
    case "TSNonNullExpression":
    case "TSAsExpression":
    case "TSTypeAssertion":
      return isStaticExpression(node.expression);
  }
  if (isLiteralType(node))
    return true;
  return false;
}
function isLiteralType(node) {
  return node.type.endsWith("Literal");
}







exports.babelParse = babelParse; exports.isCallOf = isCallOf; exports.checkInvalidScopeReference = checkInvalidScopeReference; exports.isStaticExpression = isStaticExpression; exports.isLiteralType = isLiteralType;
