import {
  filterMacro,
  hasPropsOrEmits
} from "./chunk-ABUCOAYI.mjs";

// src/core/transform.ts
import {
  DEFINE_OPTIONS,
  checkInvalidScopeReference,
  parseSFC
} from "@vue-macros/common";
import { walkAST } from "ast-walker-scope";
var transform = (ctx) => {
  var _a;
  const { code } = ctx;
  if (!code.includes(DEFINE_OPTIONS))
    return;
  const { sfc, s, id } = ctx;
  const { scriptSetup, scriptCompiled } = sfc;
  if (!scriptSetup)
    return;
  const startOffset = scriptSetup.loc.start.offset;
  const nodes = filterMacro(scriptCompiled.scriptSetupAst);
  if (nodes.length === 0)
    return;
  else if (nodes.length > 1)
    throw new SyntaxError(`duplicate ${DEFINE_OPTIONS}() call`);
  if ((_a = scriptCompiled.scriptAst) == null ? void 0 : _a.some(
    (node2) => node2.type === "ExportDefaultDeclaration"
  ))
    throw new SyntaxError(
      `${DEFINE_OPTIONS} cannot be used with default export within <script>.`
    );
  const [node] = nodes;
  const [arg] = node.arguments;
  if (!(node.arguments.length === 1 && arg.type === "ObjectExpression")) {
    throw new SyntaxError(`${DEFINE_OPTIONS}() arguments error`);
  }
  if (hasPropsOrEmits(arg)) {
    throw new SyntaxError(
      `${DEFINE_OPTIONS}() please use defineProps or defineEmits instead.`
    );
  }
  const scriptBindings = [];
  {
    const sfc2 = parseSFC(s.toString(), id);
    if (sfc2.scriptCompiled.scriptSetupAst)
      scriptBindings.push(
        ...getIdentifiers(sfc2.scriptCompiled.scriptSetupAst)
      );
  }
  checkInvalidScopeReference(arg, DEFINE_OPTIONS, scriptBindings);
  const argText = code.slice(startOffset + arg.start, startOffset + arg.end);
  ctx.scriptCode.append += `import { defineComponent as DO_defineComponent } from 'vue';
export default /*#__PURE__*/ DO_defineComponent(${argText});
`;
  s.remove(startOffset + node.start, startOffset + node.end);
};
var getIdentifiers = (stmts) => {
  let ids = [];
  walkAST(
    {
      type: "Program",
      body: stmts,
      directives: [],
      sourceType: "module",
      sourceFile: ""
    },
    {
      enter(node) {
        if (node.type === "BlockStatement") {
          this.skip();
        }
      },
      leave(node) {
        if (node.type !== "Program")
          return;
        ids = Object.keys(this.scope);
      }
    }
  );
  return ids;
};

export {
  transform
};
